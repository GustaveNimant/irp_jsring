<!-- UploadBlock -->

<!-- CreateDirectoryBlock -->

<!-- RemoveBlock -->

<!-- PinBlock -->

<!-- CurrentMfsDirectoryBlock -->

<!-- HiddenForDirBlock -->

<!-- WindowOnLoad -->

<!-- Table Functions -->
 
<!-- Pin Functions -->

<script>
    
 function createPinButtonOfHash (hash) {
     console.log('createPinButtonOfHash.input.hash:',hash);

     let but = '<button type="submit" class="pinButton" onclick="togglePinStatus(this.value, this.name)" name="'+hash+'">';

     but += '<img src="images/questionmark.png" class="' + hash + '" style="height: 24px;">';
     but += '</button>';
     console.log('createPinButtonOfHash.but:', but);

     updatePinButtonOfHash(hash);
     return but;
 }

 function togglePinStatus(status, hash) {
     console.log('togglePinStatus.input.status:',status);
     console.log('togglePinStatus.input.hash:',hash);
     
     if (status == 'unpinned' || status == 'indirect-through') {
	 return ipfsPinAdd(hash)
	     .then( _ => { updatePinButtonOfHash(hash) })
	 console.log('togglePinStatus.status:',status); // Improve
     } else if (status == 'direct' || status == 'recursive' || status == 'indirect-through')  {
	 return ipfsPinRm(hash)
	     .then( _ => { updatePinButtonOfHash(hash) })
     } else {
	 console.log('togglePinStatus.status:',status); // Improve
     }
 }
 
 function updatePinButtonOfHash(hash) {
     // Update button defined in createPinButtonOfHash (hash)
     // with name=hash. Toggling by clicking.
     console.log('updatePinButtonOfHash.input.hash:',hash);

     return getPinStatus(hash)
	 .then( status => {
	     console.log('updatePinButtonOfHash.status 1:',status);
	     //status : 'pinned-indirect through Qma84TiiJye6mp4iJZ8ZtZBWqNEqJ3JyAfMXFXy94jgE2A'
	     if (status.indexOf('through') >= 0) {
		 let string = status.split(' ');
		 console.log('updatePinButtonOfHash.string:',string);
		 var thrHash = string[2];
		 console.log('updatePinButtonOfHash.through.hash:', thrHash);
		 var status = string[0]+'-'+string[1];
	     }
	     console.log('updatePinButtonOfHash.status 2:',status);
	     img = document.getElementsByClassName(hash)[0];
	     if ( thrHash ) {
		 img.title = 'indirect through ' + thrHash;
	     } else {
		 img.title = status;
	     }
	     img.src = 'images/pinned-'+status+'-200.png';
	     button = document.getElementsByName(hash)[0];
	     button.value = status;
	     console.log('updatePinButtonOfHash.img:',img);
	     console.log('updatePinButtonOfHash.button:',button);
	 })
	 .catch(logError)
 }
 
 function getPinStatus(hash) {
     console.log('getPinStatus.input.hash:',hash);
     
     const api_url = 'http://127.0.0.1:5001/api/v0/'
     let  url = api_url + 'pin/ls?arg=/ipfs/'+hash+'&type=all'
     return fetchRespNoCatch(url)
	 .then( obj => {
	     let status;
	     if (typeof(obj.Code) == 'undefined') {
		 status = obj.Keys[hash].Type
	     } else {
		 status = 'unpinned'
	     }
	     console.log('getPinStatus: '+hash+" \u21A6",status);
	     return status
	 })
	 .catch( obj => { logError('getPinStatus.catch',obj) })
 }

 function ipfsPinAdd(hash) {
     console.log('ipfsPinAdd.input.hash:',hash);

     const api_url = 'http://127.0.0.1:5001/api/v0/'
     var url = api_url + 'pin/add?arg=/ipfs/'+hash+'&progress=true'
     console.log('ipfsPinAdd.url',url)
     return fetchGetText(url)
	 .then(text => { console.log('ipfsPinAdd.text',text); })
	 .catch(err => logErrorOfHash (err, hash))
 }

 function ipfsPinRm(hash) {
     console.log('ipfsPinRm.input.hash:',hash);
     
     const api_url = 'http://127.0.0.1:5001/api/v0/'
     var url = api_url + 'pin/rm?arg=/ipfs/'+hash
     console.log('ipfsPinRm.url',url)
     return fetchGetJson(url)
	 .then( json => { console.log('ipfsPinRm.json',json);
	     return json.Pins  // Improve when not pinned or indirect
	 })
	 .catch(err => logErrorOfHash (err, hash))
 } 
 
 /* --------------- End Pin Functions ---------------- */

 function checkedRadio () {
     console.log ('checkedRadio.entering');

     let rad = document.getElementById('UploadIdNew');
     console.log ('checkedRadio.rad:',rad);
     rad.checked = true;
     updateElementOfIdOfValue ('UploadIdNew', rad);
 }
 
 function linkIpfsHash (hash) {
     console.log ('linkIpfsHash.input.hash:',hash);
     
     let api_url = 'http://127.0.0.1:5001/ipfs/';
     let link = '<a href="';
     link += api_url;
     link += hash;
     link += '" target="_blank">';
     link += hash;
     link += '</a>';
     console.log ('linkIpfsHash link',link);
     return link;
 }

 function sizeOfJsonOfKey (json, key) {
     let siz = json[key]['Size']
     if (siz > 0) { return ' ('+siz+' octets) '; }
     else {return "";}
 }

 function typeOfJsonOfKey (json, key) {
     console.log ('typeOfJsonOfKey.input.json:', json);
     console.log ('typeOfJsonOfKey.input.key:', key);

     let result = json[key]['Type'];
     console.log ('typeOfJsonOfKey.result:', result);
     return result;
 }

 function imageOfType(type) {
     if (type == 0) { return '<img src="images/file.png" width="25px" height="25">'; }
     else { return '<img src="images/folder.png" width="25px" height="25">'; }
 }

 function typeImageOfJsonOfKey (json, key) {
     console.log('typeImageOfJsonOfKey.input.json',json);
     console.log('typeImageOfJsonOfKey.input.key',key);

     let type = typeOfJsonOfKey (json, key);
     result = imageOfType(type);
     console.log ('typeImageOfJsonOfKey.result:', result);
     return result;
 }

 function createNameButtonOfMfsDirPath (mfspath, name, type, hash) {
     console.log('createNameButtonOfMfsDirPath.input.mfspath:',mfspath);
     console.log('createNameButtonOfMfsDirPath.input.name:',name);
     console.log('createNameButtonOfMfsDirPath.input.type:',type);
     console.log('createNameButtonOfMfsDirPath.input.hash:',hash);

     let but = '<input type="button" id="nameButton" value="';
     but += name;
     if (type == 1){
	 but += '" onclick="addNameOnInputMfsPath(this.value)"';

	 var hid = document.getElementsByClassName('hiddenForFile')[0];
	 hid.hidden = false
	 var hid = document.getElementsByClassName('hiddenForDir')[0];
	 hid.hidden = true
	 
     } else {
	 but += '" onclick="displayFileOptions(' + "'" + name + "'" + ',' + "'" + hash + "'" + ')"';
	 console.log('createNameButtonOfMfsDirPath.but',but);
     }
     but += '>';
     return but;
 }

 /* ---------- File Functions ---------- */

 function displayFileOptions(name, hash) {
     var hid = document.getElementsByClassName('hiddenForFile')[0];
     hid.hidden = true;
     var hid = document.getElementsByClassName('hiddenForDir')[0];
     hid.hidden = false;

     createTableForFileOfNameOfHash (name, hash);
 }

 function createTableForFileOfNameOfHash (name, hash) {
     updateElementOfIdOfValue ('h3-title',name);

     table = document.getElementById('ls-result');
     deleteAllRowsOfTable (table);
     createHeaderOfTable (table);
     
     var tr = createElementTable (table,'tr', '');
     createElementTable (tr, 'td', createPinButtonOfHash (hash));
     createElementTable (tr, 'td', linkIpfsHash (hash));

     var tr = createElementTable (table,'tr', '');
     createElementTable (tr, 'td', buttonCopyFile (name));
     createElementTable (tr, 'td', buttonModifyFile (name));

     var tr = createElementTable (table,'tr', '');
     createElementTable (tr, 'td', buttonDeleteFile (name));
     
     console.log ('displayFileOptions.table:', table);
     getHash(hash);
 }
 
 function buttonCopyFile (name) {
     console.log('buttonCopyFile.input.name:',name);
     let butCop = '<input type="button" value="Copy ' + name + '" onclick="">';
     return butCop;
 }
 
 function buttonModifyFile (name) {
     console.log('buttonModifyFile.input.name:',name);
     
     let butMod = '<input type="button" value="Modify ' + name + '" onclick="unlockFileEdit ()">';
     return butMod;
 }

 function buttonDeleteFile (name) {
     console.log('buttonDeleteFile.input.name:',name);
     
     let path = document.getElementById ('CurrentMfsDirectoryId').value;
     if (path == '/') {
	 var mfspath = path + name
     } else {
	 var mfspath = path + '/' + name
     }
     console.log('buttonDeleteFile.mfspath:', mfspath);
     let butDel = '<input type="button" value="Delete ';
     butDel += name;
     butDel += '" onclick="removeOfMfsPath(\'';
     butDel += mfspath;
     butDel += '\')">';
     console.log('buttonDeleteFile.butDel:', butDel);
     return butDel;
 }

 function unlockFileEdit () {
     console.log('unlockFileEdit.entering');
     
     let txtAre = document.getElementById('catOfHash');
     txtAre.disabled = false;
     let butSav = document.getElementById('saveModif');
     butSav.disabled = false;
 }
 
 /* ---------- End file Functions ---------- */

 function addNameOfFileOnDeleteBlock(rootName, hash) {
     console.log('addNameOfFileOnDeleteBlock.input.rootName:',rootName);
     console.log('addNameOfFileOnDeleteBlock.input.hash:',hash);

     var mfsdir = document.getElementById('CurrentMfsDirectoryId').value;
     console.log('addNameOfFileOnDeleteBlock.mfsdir',mfsdir);
     if (mfsdir != '/') {
	 var path = mfsdir + '/' + rootName;
     }else {
	 var path = mfsdir + rootName;
     }
     console.log('addNameOfFileOnDeleteBlock path',path);
     document.getElementById('idRemoveButton').disabled = false;
     var del = document.getElementById('idRemoveFileOrDirectory');
     del.value = path;
     getHash(hash);
 }

 function addNameOnInputMfsPath (mfspath) {
     console.log ('addNameOnInputMfsPath.input.mfspath:', mfspath);

     let oldMfsdir = document.getElementById('CurrentMfsDirectoryId').value;
     console.log ('addNameOnInputMfsPath.oldMfsdir:', oldMfsdir);
     let path = oldMfsdir;
     if (oldMfsdir == '/'){
	 path += mfspath;
     } else {
	 path += '/';
	 path += mfspath;
     }
     console.log ('addNameOnInputMfsPath.path:', path);
     var del = document.getElementById('idRemoveFileOrDirectory');
     del.value = path;
     var mfsdir = document.getElementById('CurrentMfsDirectoryId');
     mfsdir.value = path;
     document.getElementById('idRemoveButton').disabled = false;
     document.getElementById('CurrentMfsDirectoryClickId').click();
 }

 function updateElementOfIdOfValue (id, value) {
     let doc = document.getElementById(id);
     doc.innerHTML = value;
 }

 function createElement (tag, id, value, input_type) {
     let doc_tag = document.createElement (tag);
     doc_tag.id = id;
     doc_tag.value = value;
     if (tag == 'input') {doc_tag.type = input_type};
     doc_tag.innerHTML = value;
     document.body.appendChild (doc_tag);
 }

 function createElementTable (ele, tag, value) {
     let doc = document.createElement (tag);
     doc.style = "padding:7px";
     doc.innerHTML = value;
     ele.appendChild (doc);
     return doc;
 }
 
 function getHash(hash) {
     console.log('getHash.input.hash:',hash)

     if (hash == "") {
	 alert("Hash must be filled out");
	 return false;
     }
     const webui = 'http://127.0.0.1:5001';
     const api_url = webui + '/api/v0/';
     var url = api_url + 'cat?&arg='+hash
     console.log('getHash.url',url);

     return fetchGetTextCors(url)
	 .then( obj => { return Promise.resolve(obj) })
	 .then(callback('catOfHash'))
	 .catch(logError)
 }

 function hashOfMfsFilePath(mfsFilePath) {
     console.log('hashOfMfsFilePath.input.mfsFilePath:',mfsFilePath);

     const api_url = 'http://127.0.0.1:5001/api/v0/'
     var url = api_url + 'files/stat?arg='+mfsFilePath+'&hash=true'
     console.log('hashOfMfsFilePath : url '+url);
     
     return fetchGetTextForm(url)
	 .then( obj => obj.json())
	 .then( json => {
	     console.log('hashOfMfsFilePath : json ',json);
	     console.log("hashOfMfsFilePath : json.Type '"+json.Type+"'");
	     if (json.Type == "error") {
		 const message = 'Error from hashOfMfsFilePath : '+json.Message;
		 console.log("hashOfMfsFilePath : message '"+message+"'")
		 updateElementOfIdOfValue("error", message);
	     }
	     return json.Hash} )
 }
 
 function logErrorOfHash (err, hash) {
     console.log("logErrorOfHash.input.err:",err);
     console.log("logErrorOfHash.input.hash:",hash);

     const message = err.message;
     console.log("logError.message:'"+message+"'");
     displayByIdOfTagOfValue("error", message);
     switch (message){
	 case "Internal Server Error":
	     var text = "Internal Server Error because ipfs file path was uncorrect<br>run : ipfs pin add "+hash;
	     displayByIdOfTagOfValue("error", text);
	     
	     break;
	     
	 default:
	     console.log("logError.default.err:'"+err+"'");
     } // switch
 }
 
 function logError (err) {
     console.log("logError.input.err:",err);
     
     const message = err.message;
     console.log("logError : message '"+message+"'");
     displayByIdOfTagOfValue("error", message);
     switch (message){
	     
	 case "NetworkError when attempting to fetch resource.":
	     var text = "NetworkError because ipfs has not been launched<br>run : jsm; . config.sh; ipmsd.sh";
	     displayByIdOfTagOfValue("error", text); 
	     break;

	 case "Failed to fetch":
	     var text = "NetworkError because ipfs has not been launched<br>run :cd minichain ; . config.sh";
	     displayByIdOfTagOfValue("error", text); 
	     break;	     

	 case "Internal Server Error":
	     //			 var text = "Internal Server Error because ipfs file path was uncorrect";
	     //			 displayByIdOfTagOfValue("error", text); 
	     return false;
	     break;
	     
	 case "Cannot read property 'length' of null":
	     console.log('logError', "Cannot read property 'length' of null");
	     displayByIdOfTagOfValue("error", '');
	     var dir = document.getElementById('CurrentMfsDirectoryId').value;
	     console.log('logError dir', dir);
	     updateElementOfIdOfValue('h3-title', dir + ' is empty');
	     break;

	 case "entries is null":
	     console.log('logError', 'entries is null');
	     displayByIdOfTagOfValue("error", '');
	     var dir = document.getElementById('CurrentMfsDirectoryId').value;
	     console.log('logError dir', dir);
	     updateElementOfIdOfValue('h3-title', dir + ' is empty');
	     break;

	 case "Cannot read property 'QmPcmWRAzbsDA25SENuZ7qRCPWYsPsWCgQV4vKPndydryc' of undefined":
	     displayByIdOfTagOfValue("error", '');
	     break;
	     
	 default:
	     console.log("logError : default err '"+err+"'");
     } // switch
 }
 
 // Library functions
 
 function baseName(mfspath){
     console.log('baseName.input.mfspath:',mfspath);
     
     var base = new String(mfspath).substring(mfspath.lastIndexOf('/') + 1); 
     if(base.lastIndexOf(".") != -1) {       
	 base = base.substring(0, base.lastIndexOf("."));
     }
     console.log('baseName.result:',result);
     return base;
 }

 function chopOfMfsPath(mfspath){
     console.log('chopOfMfsPath.input.mfspath:',mfspath);
     // MfsPath is decomposed into
     //   [ParentDirectory, BaseName, RootName, Extension]
     // Ex.: "/my/ceci/Z_block.txt" =>
     //     ["/my/ceci", "Z_block.txt", "Z_block", ".txt" ]
     if (mfspath.match('/./')) {
	 [parent,basename] = mfspath.split('/./')
     } else {
	 let p = mfspath.lastIndexOf('/')
	 // console.log('p: '+p)
	 if (p != 0) {
	     parent = mfspath.substr(0,p)
	     basename = mfspath.substr(p+1)
	 } else {
	     parent = '/';
	     basename = mfspath.substr(1)
	 }
     }
     let d = basename.lastIndexOf('.')
     if (d != -1) {
	 rootName = basename.substr(0,d)
	 ext = basename.substr(d)
     } else {
	 rootName = basename
	 ext = ''
     }
     let result = [parent, baseName, rootName, ext]; 
     console.log('chopOfMfsPath.result:',result);
     return result;
 }

 function callback (tag) {
     console.log('callback.input.tag:',tag)
     
     const result = obj => {
	 displayByIdOfTagOfValue(tag, obj); 
     };
     return result
 }
 
 function callbackIpfsIo (tag) {
     console.log('callbackIpfsIo.input.tag:',tag)

     const substi = obj => {
	 let text = "<a href=https://ipfs.io/ipfs/"+obj+">"+obj+"</a>";
	 displayByIdOfTagOfValue(tag, text);
     };
     return substi
 }
 
 function callbackIpfsLocal (tag) {
     console.log('callbackIpfsLocal.input.tag:',tag)

     const substi = obj => {
	 let text = "<a href=http://127.0.0.1:5001/ipfs/"+obj+">"+obj+"</a>";
	 displayByIdOfTagOfValue(tag, text);
     };
     return substi
 }
 
 function displayByIdOfTagOfValue (tag, value) {
     console.log('displayByIdOfTagOfValue.input.tag:',tag)
     console.log('displayByIdOfTagOfValue.input.value:',value)
     
     document.getElementById(tag).innerHTML = value
 }

 function IpfsException (message) {
     console.log('IpfsException.input.message:',message)
     
     this.message = message;
     this.name = "IpfsException";
 }
 function valueInputTextOfFormOfNameOfId(forNam, curNam, curId) {
     console.log('valueInputTextOfFormOfNameOfId.input.forNam',forNam);
     console.log('valueInputTextOfFormOfNameOfId.input.curNam',curNam);
     console.log('valueInputTextOfFormOfNameOfId.input.curId',curId);

     let form = getFormOfName(forNam);
     
     let elements = form.elements;
     console.log('valueInputTextOfFormOfNameOfId.elements:',elements);
     
     var result = "";
     for (let e=0; e <elements.length; e++) {
	 let ele = elements[e];
	 if(ele.tagName == "INPUT" && ele.type == "text"){
	     if (ele.id == curId && ele.name == curNam) {
		 result = ele.value
	     }
	 }
     }
     console.log('valueInputTextOfFormOfNameOfId.result:',result);

     if(result == "") {
	 throw "No such Input Text element in Form '" + forNam + "' '" + curNam + "' '"+ curId
     }
     return result;
 }
 
 function valueInputOfNameOfId(curNam, curId) {
     console.log('valueInputOfNameOfId.input.curNam',curNam);
     console.log('valueInputOfNameOfId.input.curId',curId);
     
     let names = document.getElementsByName(curNam);
     console.log('valueInputOfNameOfId.names',names);

     var result = "";
     for (let n=0; n <names.length; n++) {
	 if (names[n].id == curId) {
	     result = names[n].value;
	 }
     }
     console.log('valueInputOfNameOfId.result',result);
     return result
 }

 function fetchGetTextForm(url) {
     console.log('fetchGetTextForm.input.url:',url);

     return fetch(url, { method: "GET", mode: 'cors' })
 }
 
 function fetchGetJson (url) {
     console.log('fetchGetJson.input.url:',url)

     return fetch(url, { method: "GET"} )
	 .then( resp => {console.log('fetchGetJson.resp',resp); return resp.json()} )
 }

 function fetchGetPinned (url) {
     console.log('fetchGetPinned.input.url:',url)

     return fetch(url,{ method: "GET"} )
     /* 		 .then(validate) */
	 .then( resp => {console.log('fetchGetPinned resp',resp.ok); return resp.ok} )
 }

 function fetchPostMkdirForm(mfspath, url) {
     console.log('fetchPostTextForm.input.msfpath:',mfspath);
     console.log('fetchPostTextForm.input.url:',url);
     
     let form = new FormData();
     form.append('file', mfspath)   
     const result = fetch(url, {
	 method: "POST",
	 mode: 'cors',
	 body: form
     })
     return result;
 }
 
 function fetchPostTextForm(url, content) {
     console.log('fetchPostTextForm.input.url:',url);
     console.log('fetchPostTextForm.input.content:'+content);
     
     let form = new FormData();
     form.append('file', content)   
     const result = fetch(url, {
	 method: "POST",
	 mode: 'cors',
	 body: form
     })
     return result;
 }
 
 function fetchGetTextCors(url) {
     console.log('fetchGetTextCors.input.url:',url);

     return fetch(url, { method: "GET", mode: "cors"} )
	 .then(validate)
	 .then( resp => resp.text() )
 }	 
 
</script>

    </body>
</html>
